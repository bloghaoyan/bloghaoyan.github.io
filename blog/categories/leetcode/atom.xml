<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: LeetCode | Hao Yan's Blog]]></title>
  <link href="http://bloghaoyan.github.io/blog/categories/leetcode/atom.xml" rel="self"/>
  <link href="http://bloghaoyan.github.io/"/>
  <updated>2013-11-21T15:55:25+08:00</updated>
  <id>http://bloghaoyan.github.io/</id>
  <author>
    <name><![CDATA[Hao Yan]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[LeetCode OJ 001 Two Sum]]></title>
    <link href="http://bloghaoyan.github.io/blog/2013/11/21/leetcode-oj-001-two-sum/"/>
    <updated>2013-11-21T13:27:00+08:00</updated>
    <id>http://bloghaoyan.github.io/blog/2013/11/21/leetcode-oj-001-two-sum</id>
    <content type="html"><![CDATA[<h2><a href="http://oj.leetcode.com/problems/two-sum/">Two Sum</a></h2>

<h3>Description:</h3>

<blockquote><p>Given an array of integers, find two numbers such that they add up to a specific target number.<br/>
The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.<br/>
Please note that your returned answers (both index1 and index2) are <em>not zero-based</em>.<br/>
You may assume that each input would have exactly one solution.</p></blockquote>

<h3>描述：</h3>

<blockquote><p>给定一个数组，找出其中两个数加起来等于一个目标数字。
函数twoSum返回这两个数的索引值，其中index1小于index2。
索引值从1开始而不是0。
每个输入有且只有一个解。</p></blockquote>

<h3>Input:</h3>

<blockquote><p>numbers={2, 7, 11, 15}, target=9</p></blockquote>

<h3>Output:</h3>

<blockquote><p>index1=1, index2=2</p></blockquote>

<h3>思路</h3>

<blockquote><ol>
<li>暴力法：算法复杂度为O(n<sup>2</sup>)</li>
<li>先排序，再二分查找：算法复杂度O(nlogn)</li>
</ol>
</blockquote>

<h3>代码</h3>

<p>```cpp
class Solution {
public:</p>

<pre><code>int bSearch(vector&lt;int&gt; &amp;numbers, int other, int low, int high) {
    if (low&gt;high) {
        return -1;
    }
    int mid = (low+high)/2;
    if (other==numbers[mid]) {
        return mid;
    } else if (other&gt;numbers[mid]) {
        bSearch(numbers, other, mid+1, high);
    } else {
        bSearch(numbers, other, low, mid-1);
    }
}

vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;numbers, int target) {
    // IMPORTANT: Please reset any member data you declared, as
    // the same Solution instance will be reused for each test case.
    vector&lt;int&gt; backup = numbers;
    sort(numbers.begin(), numbers.end());
    for(int i=0; i&lt;backup.size(); i++) {
        int j = bSearch(numbers, target-backup[i], 0, backup.size()-1);
        if(j!=-1) {
            vector&lt;int&gt; result;
            result.push_back(i+1);
            for(int k=0; k&lt;backup.size(); k++) {
                if(backup[k]==numbers[j] &amp;&amp; k!=i) {
                    result.push_back(k+1);
                }
            }
            return result;
        }
    }
}
</code></pre>

<p>};
```</p>
]]></content>
  </entry>
  
</feed>
