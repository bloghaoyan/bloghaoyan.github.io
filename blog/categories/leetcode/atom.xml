<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: LeetCode | Hao Yan's Blog]]></title>
  <link href="http://bloghaoyan.github.io/blog/categories/leetcode/atom.xml" rel="self"/>
  <link href="http://bloghaoyan.github.io/"/>
  <updated>2013-11-22T19:27:02+08:00</updated>
  <id>http://bloghaoyan.github.io/</id>
  <author>
    <name><![CDATA[Hao Yan]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[LeetCode OJ 004 Add Two Numbers]]></title>
    <link href="http://bloghaoyan.github.io/blog/2013/11/22/leetcode-oj-004-add-two-numbers/"/>
    <updated>2013-11-22T14:46:00+08:00</updated>
    <id>http://bloghaoyan.github.io/blog/2013/11/22/leetcode-oj-004-add-two-numbers</id>
    <content type="html"><![CDATA[<blockquote><p><a href="http://oj.leetcode.com/problems/add-two-numbers/">Add Two Numbers</a></p></blockquote>

<h3>Description:</h3>

<blockquote><p>You are given two linked lists representing two non-negative numbers.<br/>
The digits are stored in reverse order and each of their nodes contain a single digit.<br/>
Add the two numbers and return it as a linked list.</p></blockquote>

<!--more-->


<h3>描述：</h3>

<blockquote><p>给定两个表示两个非负数的链表。<br/>
其中数字位按倒序存放，每个链表结点存放一位数字。<br/>
将这两个数加到一起以链表形式返回。</p></blockquote>

<h3>Input:</h3>

<blockquote><p>(2 &ndash;> 4 &ndash;> 3) + (5 &ndash;> 6 &ndash;> 4)</p></blockquote>

<h3>Output:</h3>

<blockquote><p>7 &ndash;> 0 &ndash;> 8</p></blockquote>

<h3>思路</h3>

<blockquote><ul>
<li>两次遍历：

<blockquote><p>第一次遍历加在一块，第二次遍历处理进位。</p></blockquote></li>
<li>一次遍历：

<blockquote><p>用一个变量存放进位。</p></blockquote></li>
</ul>
</blockquote>

<h3>代码</h3>

<p>```cpp
struct ListNode {</p>

<pre><code>int val;
ListNode *next;
ListNode(int x) : val(x), next(NULL) {}
</code></pre>

<p>};
```</p>

<ul>
<li>两次遍历</li>
</ul>


<p>```cpp
class Solution {
public:</p>

<pre><code>ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {
    // IMPORTANT: Please reset any member data you declared, as
    // the same Solution instance will be reused for each test case.
    ListNode *l = new ListNode(0);
    ListNode *p = l;
    ListNode *temp = NULL;
    while(l1 &amp;&amp; l2) {
        temp = new ListNode(l1-&gt;val+l2-&gt;val);
        p-&gt;next = temp;
        p = p-&gt;next;
        l1 = l1-&gt;next;
        l2 = l2-&gt;next;
    }
    while(l1) {
        temp = new ListNode(l1-&gt;val);
        p-&gt;next = temp;
        p = p-&gt;next;
        l1 = l1-&gt;next;
    }
    while(l2) {
        temp = new ListNode(l2-&gt;val);
        p-&gt;next = temp;
        p = p-&gt;next;
        l2 = l2-&gt;next;
    }
    p = l-&gt;next;
    while(p-&gt;next) {
        if(p-&gt;val&gt;=10) {
            p-&gt;val %= 10;
            p-&gt;next-&gt;val++;
        }
        p = p-&gt;next;
    }
    if(p-&gt;val&gt;=10) {
        temp = new ListNode(p-&gt;val/10);
        p-&gt;val %= 10;
        p-&gt;next = temp;
    }
    return l-&gt;next;
}
</code></pre>

<p>};
```</p>

<ul>
<li>一次遍历</li>
</ul>


<p>```cpp
class Solution {
public:</p>

<pre><code>ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {
    // IMPORTANT: Please reset any member data you declared, as
    // the same Solution instance will be reused for each test case.
    ListNode *l = new ListNode(0);
    ListNode *p = l;
    ListNode *temp = NULL;
    int carry = 0;
    while(l1 &amp;&amp; l2) {
        temp = new ListNode((l1-&gt;val+l2-&gt;val+carry)%10);
        carry = (l1-&gt;val+l2-&gt;val+carry)/10;
        p-&gt;next = temp;
        p = p-&gt;next;
        l1 = l1-&gt;next;
        l2 = l2-&gt;next;
    }
    while(l1) {
        temp = new ListNode((l1-&gt;val+carry)%10);
        carry = (l1-&gt;val+carry)/10;
        p-&gt;next = temp;
        p = p-&gt;next;
        l1 = l1-&gt;next;
    }
    while(l2) {
        temp = new ListNode((l2-&gt;val+carry)%10);
        carry = (l2-&gt;val+carry)/10;
        p-&gt;next = temp;
        p = p-&gt;next;
        l2 = l2-&gt;next;
    }
    if(carry) {
        temp = new ListNode(carry);
        p-&gt;next = temp;
    }
    return l-&gt;next;
}
</code></pre>

<p>};
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LeetCode OJ 003 Longest Substring Without Repeating Characters]]></title>
    <link href="http://bloghaoyan.github.io/blog/2013/11/22/leetcode-oj-003-longest-substring-without-repeating-characters/"/>
    <updated>2013-11-22T09:01:00+08:00</updated>
    <id>http://bloghaoyan.github.io/blog/2013/11/22/leetcode-oj-003-longest-substring-without-repeating-characters</id>
    <content type="html"><![CDATA[<blockquote><p><a href="http://oj.leetcode.com/problems/longest-substring-without-repeating-characters/">Longest Substring Without Repeating Characters</a></p></blockquote>

<h3>Description:</h3>

<blockquote><p>Given a string, find the length of the longest substring without repeating characters.<br/>
For example, the longest substring without repeating letters for &ldquo;abcabcbb&rdquo; is &ldquo;abc&rdquo;, which the length is 3. For &ldquo;bbbbb&rdquo; the longest substring is &ldquo;b&rdquo;, with the length of 1.</p></blockquote>

<!--more-->


<h3>描述：</h3>

<blockquote><p>给定一个字符串，找出其中无重复字符的最长子串的长度。<br/>
例如，对于"abcabcbb"，无重复字符的最长子串是"abc"，它的长度是3。对于"bbbbb" ，无重复字符的最长子串是"b"，它的长度是1。</p></blockquote>

<h3>思路</h3>

<blockquote><ul>
<li>简单思路：

<blockquote><p>维护两个指针low和i，i一直向前走，low指向目前无重复字符的子串(<em>不一定是最长</em>)的起始位置。i每读入一个字符，查看其是否在low和i之间有重复，若有则计算目前子串长度是否比之前更长，然后low更新为重复位置+1，这种方法时间复杂度O(n<sup>2</sup>)。</p></blockquote></li>
<li>更好的思路：

<blockquote><p>维护一个大小为256的记录表table和两个指针low和i，table记录每个已遇到的字符的索引值，i一直向前走，low指向目前无重复字符的子串(<em>不一定是最长</em>)的起始位置。i每读入一个字符，从table中查看该字符是否之前已经出现过，若出现过且原索引在low和i之间，则计算目前子串长度是否比之前更长，然后将low更新为该字符原索引+1，将该字符的索引更新为i，这种方法时间复杂度O(n)。</p></blockquote></li>
</ul>
</blockquote>

<h3>代码</h3>

<ul>
<li>O(n<sup>2</sup>)方法
<code>cpp
class Solution {
public:
  int lengthOfLongestSubstring(string s) {
      // IMPORTANT: Please reset any member data you declared, as
      // the same Solution instance will be reused for each test case.
      if(s=="") {
          return 0;
      }
      int low = 0;
      int max = 0;
      int i=1;
      for(; i&lt;s.size();i++) {
          int pos = s.find(s[i], low);
          if(pos&lt;=i-1) {
              if(i-low&gt;max) {
                  max = i-low;
              }
              low = pos+1;
          }
      }
      if(i-low&gt;max) {
          max = i-low;
      }
      return max;
  }
};
</code></li>
<li><p>O(n)方法
```cpp
class Solution {
public:
  int lengthOfLongestSubstring(string s) {
      // IMPORTANT: Please reset any member data you declared, as
      // the same Solution instance will be reused for each test case.
      if(s==&ldquo;&rdquo;) {
          return 0;
      }</p>

<pre><code>  int rTable[256];
  for(int i=0; i&lt;256; i++) {
      rTable[i] = -1;
  }

  int low = -1;
  int max = 0;
  int i=0;
  for(; i&lt;s.size(); i++) {
      if(rTable[(int)s[i]]&gt;=low) {
          if(i-low&gt;max) {
              max = i-low;
          }
          low = rTable[(int)s[i]]+1;
      }
      rTable[(int)s[i]] = i;
  }

  if(i-low&gt;max) {
      max = i-low;
  }

  return max;
</code></pre>

<p>  }
};
```</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LeetCode OJ 002 Median of Two Sorted Arrays]]></title>
    <link href="http://bloghaoyan.github.io/blog/2013/11/21/leetcode-oj-002-median-of-two-sorted-arrays/"/>
    <updated>2013-11-21T20:59:00+08:00</updated>
    <id>http://bloghaoyan.github.io/blog/2013/11/21/leetcode-oj-002-median-of-two-sorted-arrays</id>
    <content type="html"><![CDATA[<blockquote><p><a href="http://oj.leetcode.com/problems/median-of-two-sorted-arrays/">Median of Two Sorted Arrays</a></p></blockquote>

<h3>Description:</h3>

<blockquote><p>There are two sorted arrays A and B of size m and n respectively. <br/>
Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p></blockquote>

<!--more-->


<h3>描述：</h3>

<blockquote><p>给定两个已排序的数组A和B，大小分别为m和n。<br/>
找出这两个数组的中值。<br/>
要求时间复杂度为O(log (m+n))。</p></blockquote>

<h3>思路</h3>

<blockquote><p>相当于做归并。本题中若m+n为偶数则中值是中间两个数的平均值。</p></blockquote>

<h3>代码</h3>

<p>```cpp
class Solution {
public:</p>

<pre><code>double findMedianSortedArrays(int A[], int m, int B[], int n) {
    // IMPORTANT: Please reset any member data you declared, as
    // the same Solution instance will be reused for each test case.
    int mid = (m+n)/2;
    int *temp = new int[mid+1];
    int i = 0;
    int j = 0;
    int k = 0;
    for(; i&lt;m &amp;&amp; j&lt;n &amp;&amp; k&lt;=mid; k++) {
        if(A[i]&lt;B[j]) {
            temp[k] = A[i++];
        } else {
            temp[k] = B[j++];
        }
    }

    if(i==m) {
        for(; k&lt;=mid; k++) {
            temp[k] = B[j++];
        }
    } else if(j==n) {
        for(; k&lt;=mid; k++) {
            temp[k] = A[i++];
        }
    }
    double result = 0;
    if((m+n)%2 == 0) {
        result = (temp[mid]+temp[mid-1])/2.0;
    } else {
        result = temp[mid]*1.0;
    }

    delete[] temp;
    return result;
}
</code></pre>

<p>};
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LeetCode OJ 001 Two Sum]]></title>
    <link href="http://bloghaoyan.github.io/blog/2013/11/21/leetcode-oj-001-two-sum/"/>
    <updated>2013-11-21T13:27:00+08:00</updated>
    <id>http://bloghaoyan.github.io/blog/2013/11/21/leetcode-oj-001-two-sum</id>
    <content type="html"><![CDATA[<blockquote><p><a href="http://oj.leetcode.com/problems/two-sum/">Two Sum</a></p></blockquote>

<h3>Description:</h3>

<blockquote><p>Given an array of integers, find two numbers such that they add up to a specific target number.<br/>
The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.<br/>
Please note that your returned answers (both index1 and index2) are <em>not zero-based</em>.<br/>
You may assume that each input would have exactly one solution.</p></blockquote>

<!--more-->


<h3>描述：</h3>

<blockquote><p>给定一个数组，找出其中两个数加起来等于一个目标数字。<br/>
函数twoSum返回这两个数的索引值，其中index1小于index2。<br/>
索引值从1开始而不是0。<br/>
每个输入有且只有一个解。</p></blockquote>

<h3>Input:</h3>

<blockquote><p>numbers={2, 7, 11, 15}, target=9</p></blockquote>

<h3>Output:</h3>

<blockquote><p>index1=1, index2=2</p></blockquote>

<h3>思路</h3>

<blockquote><ol>
<li>暴力法：算法复杂度为O(n<sup>2</sup>)</li>
<li>先排序，再二分查找：算法复杂度O(nlogn)</li>
</ol>
</blockquote>

<h3>代码</h3>

<p>```cpp
class Solution {
public:</p>

<pre><code>int bSearch(vector&lt;int&gt; &amp;numbers, int other, int low, int high) {
    if (low&gt;high) {
        return -1;
    }
    int mid = (low+high)/2;
    if (other==numbers[mid]) {
        return mid;
    } else if (other&gt;numbers[mid]) {
        bSearch(numbers, other, mid+1, high);
    } else {
        bSearch(numbers, other, low, mid-1);
    }
}

vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;numbers, int target) {
    // IMPORTANT: Please reset any member data you declared, as
    // the same Solution instance will be reused for each test case.
    vector&lt;int&gt; backup = numbers;
    sort(numbers.begin(), numbers.end());
    for(int i=0; i&lt;backup.size(); i++) {
        int j = bSearch(numbers, target-backup[i], 0, backup.size()-1);
        if(j!=-1) {
            vector&lt;int&gt; result;
            result.push_back(i+1);
            for(int k=0; k&lt;backup.size(); k++) {
                if(backup[k]==numbers[j] &amp;&amp; k!=i) {
                    result.push_back(k+1);
                }
            }
            return result;
        }
    }
}
</code></pre>

<p>};
```</p>
]]></content>
  </entry>
  
</feed>
